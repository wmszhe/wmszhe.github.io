<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wmszhe.github.io/</id>
    <title>wzhuiJ</title>
    <updated>2020-09-05T02:14:37.873Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wmszhe.github.io/"/>
    <link rel="self" href="https://wmszhe.github.io/atom.xml"/>
    <subtitle>Hello EveryOne 😘</subtitle>
    <logo>https://wmszhe.github.io/images/avatar.png</logo>
    <icon>https://wmszhe.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, wzhuiJ</rights>
    <entry>
        <title type="html"><![CDATA[Android添加一个view到多个view中]]></title>
        <id>https://wmszhe.github.io/post/android_add_view_multiple_times/</id>
        <link href="https://wmszhe.github.io/post/android_add_view_multiple_times/">
        </link>
        <updated>2020-09-02T09:16:50.000Z</updated>
        <summary type="html"><![CDATA[<p>Java Class.forName</p>
]]></summary>
        <content type="html"><![CDATA[<p>Java Class.forName</p>
<!-- more -->
<h3 id="android添加一个view到多个view中">Android添加一个view到多个view中</h3>
<blockquote>
<p>假如有一个view: View view = new View();</p>
<p>有多个FrameLayout: FrameA，FrameB</p>
<p>如果要将view添加到FrameA，FrameB，调用FrameA.addView(view)，再FrameB.addView(view)时，会提示view已经有一个父View了，不能添加成功。</p>
</blockquote>
<p>此时，我们可以通过Class.forName，来实现这个功能</p>
<pre><code>try {
    // 根据view加载view的class
    Class&lt;?&gt; clazz = Class.forName(view.getClass().getName());
    // 调用带Context的构造函数
    Constructor&lt;?&gt; constructor = clazz.getConstructor(Context.class);
    // 生成一个新的view对象
    View view = (View) constructor.newInstance(mContext);
    // 添加
    frame.addView(view);
} catch (Exception e) {
    e.printStackTrace();
}
</code></pre>
<h3 id="classforname说明">Class.forName说明</h3>
<h4 id="一-什么时候用classforname">一. 什么时候用Class.forName()</h4>
<p>给你一个字符串变量，它代表一个类的包名和类名，你怎么实例化它？你第一想到的肯定是new，但是注意一点：<br>
A a = (A)Class.forName(“pacage.A”).newInstance();<br>
A a = new A();</p>
<p>是一样的效果。</p>
<h4 id="二-用法">二. 用法</h4>
<blockquote>
<p>如果被调用的类的构造函数为默认的构造函数，采用Class.newInstance()</p>
<p>如果需要调用类的带参构造函数、私有构造函数， 就需要采用Constractor.newInstance()</p>
</blockquote>
<ol>
<li>
<p>加载无参数的类</p>
<pre><code>try {
    Class&lt;?&gt; clazz = Class.forName(&quot;A&quot;);
    A a = (A) clazz.newInstance();
} catch (Exception e) {
    e.printStackTrace();
}
</code></pre>
</li>
<li>
<p>加载有参数的类</p>
<pre><code>// 带context参数
try {
    Class&lt;?&gt; clazz = Class.forName(&quot;A&quot;);
    Constructor&lt;?&gt; constructor = clazz.getConstructor(Context.class);
    A a = (A) constructor.newInstance(mContext);
} catch (Exception e) {
    e.printStackTrace();
}
// 其他参数
try {
    Class&lt;?&gt; clazz = Class.forName(&quot;A&quot;);
    Constructor&lt;?&gt; constructor = clazz.getConstructor(new Class[]{int.class, String.class});
    A a = (A) constructor.newInstance(new Object[]{5, &quot;abc&quot;});
} catch (Exception e) {
    e.printStackTrace();
}
</code></pre>
</li>
</ol>
<h3 id="参考">参考</h3>
<ol>
<li><a href="">https://blog.csdn.net/kaiwii/article/details/7405761</a></li>
<li><a href="">https://www.cnblogs.com/xiaoenduke/p/10854657.html</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AS3.0以后，debug包INSTALL_FAILED_TEST_ONLY问题]]></title>
        <id>https://wmszhe.github.io/post/as_testOnly/</id>
        <link href="https://wmszhe.github.io/post/as_testOnly/">
        </link>
        <updated>2020-06-30T08:28:59.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>Android Studio 3.0以后，通过IDE直接run出来的安装包，有些手机无法直接安装，会提示<code>Failed to install app-debug.apk: Failure [INSTALL_FAILED_TEST_ONLY: installPackage]</code></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>Android Studio 3.0以后，通过IDE直接run出来的安装包，有些手机无法直接安装，会提示<code>Failed to install app-debug.apk: Failure [INSTALL_FAILED_TEST_ONLY: installPackage]</code></p>
</blockquote>
<!-- more -->
<h3 id="问题">问题</h3>
<p>Android Studio 3.0以后，通过IDE直接run出来的安装包，无法直接安装，也无法通过<code>adb install xx.apk</code>的方式来安装。会提示<code>Failed to install app-debug.apk: Failure [INSTALL_FAILED_TEST_ONLY: installPackage]</code></p>
<p>大多数手机上，我们可以通过<code>adb install -t xx.apk</code>的方式来安装，但是某些<code>OPPO</code>手机上，还是无法安装。</p>
<h3 id="原因">原因</h3>
<p>IDE 直接 Run 出来的 APK ，会在 AndroidManifest.xml 文件中，增加 <code>android:testOnly=&quot;true&quot;</code> 属性，正是因为这个属性，阻止了我们使用正常方式安装 APK。</p>
<h3 id="解决方法">解决方法</h3>
<h5 id="1-方法一修改打包方式">1. 方法一（修改打包方式）</h5>
<ol>
<li>当我们需要debug包的时候，不使用IDE直接run跑出的apk，而是通过IDE中gradle中，app-build-build命令来生成</li>
<li>通过IDE菜单工具栏-Build-Build Bundle(s)/APK(s)来生成apk</li>
</ol>
<h5 id="2-方法二会造成其他问题不推荐">2. 方法二（会造成其他问题，不推荐）</h5>
<p>在项目gradle.properties(或者gradle全局配置目录 ~/.gradle/)文件中添加<code>android.injected.testOnly=false</code></p>
<p><mark>此方法，会造成IDE run apk的时候，app无法直接打开启动页面，直接返回到桌面</mark></p>
<h3 id="不同方式打包反编译结果">不同方式打包，反编译结果</h3>
<ol>
<li>
<p>IDE直接run出来的apk</p>
<p><mark>带有<code>android:testOnly=&quot;true&quot;</code></mark></p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/wmszhe/pichub/master/imgs/mAUnTd.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/wmszhe/pichub/master/imgs/VvYXPZ.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>gradle-app-build-build编译出的apk</p>
<p><mark>不带<code>android:testOnly=&quot;true&quot;</code></mark></p>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/wmszhe/pichub/master/imgs/rXpCsw.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/wmszhe/pichub/master/imgs/drCtsQ.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>IDE菜单工具栏-Build-Build Bundle(s)/APK(s)编译出的apk</p>
<p><mark>不带<code>android:testOnly=&quot;true&quot;</code></mark></p>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/wmszhe/pichub/master/imgs/gjFOvf.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://raw.githubusercontent.com/wmszhe/pichub/master/imgs/AFMm6U.png" alt="" loading="lazy"></figure>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[IDEA相关]]></title>
        <id>https://wmszhe.github.io/post/idea_tips/</id>
        <link href="https://wmszhe.github.io/post/idea_tips/">
        </link>
        <updated>2020-02-27T02:53:20.000Z</updated>
        <summary type="html"><![CDATA[<p>IDEA相关 ，持续更新</p>
]]></summary>
        <content type="html"><![CDATA[<p>IDEA相关 ，持续更新</p>
<!-- more -->
<h3 id="一-分类显示类方法">一. 分类显示类方法</h3>
<blockquote>
<p>参考 <a href="https://www.v2ex.com/t/647696">为什么 idea 不做一个分类显示类方法的功能？</a></p>
</blockquote>
<pre><code>// region foo
// endregion foo
</code></pre>
<p>eg:</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/wmszhe/pichub/master/imgs/hXmEX6.jpg" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/wmszhe/pichub/master/imgs/zGWown.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android生成jks时遇到的]]></title>
        <id>https://wmszhe.github.io/post/android_jks/</id>
        <link href="https://wmszhe.github.io/post/android_jks/">
        </link>
        <updated>2019-11-01T02:57:53.000Z</updated>
        <summary type="html"><![CDATA[<p>keytool -importkeystore -srckeystore /Users/zhe/Desktop/Test.jks -destkeystore /Users/zhe/Desktop/Test_sign.jks -deststoretype PKCS12</p>
]]></summary>
        <content type="html"><![CDATA[<p>keytool -importkeystore -srckeystore /Users/zhe/Desktop/Test.jks -destkeystore /Users/zhe/Desktop/Test_sign.jks -deststoretype PKCS12</p>
<!-- more -->
<h3 id="生成jks">生成jks</h3>
<ol>
<li>通过AndroidStudio生成</li>
<li>通过命令生成</li>
</ol>
<h4 id="生成jks文件后会有个warning">生成jks文件后，会有个Warning</h4>
<blockquote>
<p>jks密钥库使用专用格式建议使用keytool my release key keystore my release key keystore pkcs12迁移到行业标准格式pkcs12</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/wmszhe/pichub/master/imgs/QQ20191101-104757@2x.png" alt="" loading="lazy"></figure>
<h4 id="解决方案">解决方案：</h4>
<pre><code>keytool -importkeystore -srckeystore srckey -destkeystore targetkey -deststoretype pkcs12
</code></pre>
<p><mark>注意srckey和targetkey不能相同,否则会报如下错误</mark></p>
<pre><code>keytool 错误: java.io.IOException: DerInputStream.getLength(): lengthTag=109, too big.
</code></pre>
<h4 id="eg">eg:</h4>
<pre><code>keytool -importkeystore -srckeystore /Users/zhe/Desktop/Test.jks -destkeystore /Users/zhe/Desktop/Test_sign.jks -deststoretype PKCS12
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Flutter遇到的问题]]></title>
        <id>https://wmszhe.github.io/post/flutter_qa/</id>
        <link href="https://wmszhe.github.io/post/flutter_qa/">
        </link>
        <updated>2019-08-22T08:05:24.000Z</updated>
        <summary type="html"><![CDATA[<p>Flutter开发过程中遇到的一些问题。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Flutter开发过程中遇到的一些问题。</p>
<!-- more -->
<h3 id="1-android设置splash时图片拉伸解决方法">1. Android设置Splash时图片拉伸解决方法</h3>
<p><strong>设置splash：</strong></p>
<p>res/drawable/launch_backgroud.xml中，item-bitmap设置splash图片</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
    &lt;item android:drawable=&quot;@android:color/white&quot; /&gt;
    &lt;item&gt;
        &lt;bitmap
            android:gravity=&quot;center|bottom&quot;
            android:src=&quot;@mipmap/tk_splash&quot; /&gt;
    &lt;/item&gt;
&lt;/layer-list&gt;
</code></pre>
<p><strong>图片拉伸解决方法</strong></p>
<p><mark><strong>图片要放在mipmap中，不能放在drawable中</strong></mark></p>
<p>mipmap分多个分辨率的文件夹。<mark>如果只使用一张图片的话</mark>，放在mipmap-mdpi下，图片会偏大，放在mipmap-xxxhdpi文件夹下，图片会偏小。经测试，放在mipmap-xhdpi文件夹下合适。</p>
<p><mark><strong>原因参考 <a href="https://blog.csdn.net/guolin_blog/article/details/50727753">Android drawable微技巧，你所不知道的drawable的那些细节</a></strong></mark></p>
<h3 id="2-多语言支持ios无效只显示英文">2. 多语言支持iOS无效，只显示英文</h3>
<p>参考<a href="https://flutter.dev/docs/development/accessibility-and-localization/internationalization#appendix-updating-the-ios-app-bundle">Appendix: Updating the iOS app bundle</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[洗牌算法]]></title>
        <id>https://wmszhe.github.io/post/shuffle_algorithm/</id>
        <link href="https://wmszhe.github.io/post/shuffle_algorithm/">
        </link>
        <updated>2019-07-16T03:43:56.000Z</updated>
        <summary type="html"><![CDATA[<p>最近在知乎看到了一个关于洗牌算法，学习一下，记录下。</p>
<p>源地址：<a href="https://www.zhihu.com/question/26934313/answer/743798587">知乎：有哪些算法惊艳到了你?</a></p>
]]></summary>
        <content type="html"><![CDATA[<p>最近在知乎看到了一个关于洗牌算法，学习一下，记录下。</p>
<p>源地址：<a href="https://www.zhihu.com/question/26934313/answer/743798587">知乎：有哪些算法惊艳到了你?</a></p>
<!-- more -->
<h3 id="问题设计一个公平的洗牌算法">问题：设计一个公平的洗牌算法</h3>
<p>给定一个长度n个数组，最终排列的可能性一共有 n!个，公平的洗牌算法，<strong>应该能等概率地给出这 n! 个结果中的任意一个</strong>。</p>
<p>我们再换一个角度思考“公平”这个话题。其实也就是，对于生成的排列，<strong>每一个元素都能独立等概率地出现在每一个位置</strong>。或者反过来，<strong>每一个位置都能独立等概率地放置每个元素</strong>。</p>
<h4 id="java实现">Java实现</h4>
<pre><code>private static Random rand = new Random();
private static List&lt;Integer&gt; mList = Arrays.asList(1, 2, 3, 4, 5);

public static void main(String[] args) {
    List&lt;Integer&gt; shuffle = shuffle(mList);
    System.out.print(shuffle.toString());
}

private static List&lt;Integer&gt; shuffle(List&lt;Integer&gt; list) {
    for (int i = list.size() - 1; i &gt;= 0; i--) {
        // 取0-i之间的随机数
        int j = rand.nextInt(i + 1);
        // 交换最后一位和随机得到的数
        swap(list, i, j);
    }
    return list;
}

private static void swap(List&lt;Integer&gt; list, int i, int j) {
    Integer temp = list.get(i);
    list.set(i, list.get(j));
    list.set(j, temp);
}
</code></pre>
<h4 id="java自带api">Java自带API</h4>
<p>在Java提供的Collections包中，提供了shuffle方法</p>
<pre><code>Collections.shuffle(mList);
</code></pre>
<p>看下源码:</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/wmszhe/pichub/master/imgs/shuffle_java_2019_7_16_11_21_29.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/wmszhe/pichub/master/imgs/shuffle_java_2019_7_16_11_21_56.png" alt="" loading="lazy"></figure>
<p>可以看出，和上面的思路一样</p>
<h4 id="思路解析参考上面的链接知乎的原答案">思路解析，参考上面的链接，知乎的原答案</h4>
<p>比如数组1，2，3，4，5</p>
<p>我们从后往前</p>
<p>先取任意1个元素和最后一个交换位置，那么任意一个元素出现在数组最后面的概率为1/5</p>
<p>我们继续，取任意一个元素和倒数第二个交换位置，概率为4/5*1/4=1/5</p>
<p>依次类推，每一个元素出现在每一个位置的概率，都是 1/5</p>
<h4 id="遍历时为什么采用从后到前的方式而不采用从前到后">遍历时，为什么采用从后到前的方式，而不采用从前到后？</h4>
<p><mark><strong>因为生成 [0, i] 范围的随机数比生成 [i, n) 范围的随机数简单</strong></mark></p>
<ul>
<li>生成[0, i]范围的随机数</li>
</ul>
<pre><code>Random rand = new Random();
int randNum = ran.nextInt(i + 1);
</code></pre>
<ul>
<li>生成[i, n)范围的随机数</li>
</ul>
<pre><code>Random rand = new Random();
int randNum = rand.nextInt(n - i) + i;
</code></pre>
<h4 id="参考">参考：</h4>
<p><a href="https://justdo2008.iteye.com/blog/1927222">随机打乱数组List洗牌算法shuffle</a></p>
<p><a href="https://github.com/giantray/stackoverflow-java-top-qa/blob/master/contents/generating-random-integers-in-a-range-with-Java.md">java 产生指定范围的随机数</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[查找算法]]></title>
        <id>https://wmszhe.github.io/post/search_algorithm/</id>
        <link href="https://wmszhe.github.io/post/search_algorithm/">
        </link>
        <updated>2019-07-04T06:44:03.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h2 id="查找算法">查找算法</h2>
<h3 id="二分查找">二分查找</h3>
<blockquote>
<p><mark><strong>二分查找必须是有序对</strong></mark></p>
</blockquote>
<blockquote>
<p>有序的序列，每次都是以序列的中间位置的数来与待查找的关键字进行比较，每次缩小一半的查找范围，直到匹配成功。</p>
</blockquote>
<p>优点是比较次数少，查找速度快，平均性能好；</p>
<p>其缺点是要求待查表为有序表，且插入删除困难。</p>
<p>因此，折半查找方法适用于不经常变动而查找频繁的有序列表。</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/wmszhe/pichub/master/imgs/20171009001641524.jpeg" alt="" loading="lazy"></figure>
<h4 id="while循环实现">while循环实现</h4>
<blockquote>
<p>最好时间复杂度：O(1)</p>
</blockquote>
<blockquote>
<p>最差时间复杂度：O(logn)</p>
</blockquote>
<blockquote>
<p>空间复杂度：O(1)</p>
</blockquote>
<pre><code>/**
 * 二分查找 while实现
 * @param aar 数组
 * @param key 需要查找的元素
 * @return 所查询元素的下标
 */
fun binarySearch(aar: IntArray, key: Int): Int {
    var low: Int = 0
    var high: Int = aar.size - 1
    if (aar[low] &gt; key || aar[high] &lt; key || low &gt; high) {
        return -1
    }
    var mid: Int = 0
    while (low &lt;= high) {
        mid = (low + high) / 2
        when {
            aar[mid] &lt; key -&gt; low = mid + 1
            aar[mid] &gt; key -&gt; high = mid - 1
            else -&gt; return mid
        }
    }
    return -1
}
</code></pre>
<h4 id="递归实现">递归实现</h4>
<blockquote>
<p>最好时间复杂度：O(1)</p>
</blockquote>
<blockquote>
<p>最差时间复杂度：O(logn)</p>
</blockquote>
<blockquote>
<p>空间复杂度：O(logn)</p>
</blockquote>
<pre><code>/**
 * 二分查找 递归实现
 * @param aar 数组
 * @param key 需要查找的元素
 * @param low 较小的下标
 * @param high 较大的下标
 * @return 所查询元素的下标
 */
fun binarySearchForRecursion(aar: IntArray, key: Int, low: Int, high: Int): Int {
    if (aar[low] &gt; key || aar[high] &lt; key || low &gt; high) {
        return -1
    }
    val mid: Int = (low + high) / 2
    return when {
        aar[mid] &lt; key -&gt; binarySearchForRecursion(aar, key, mid + 1, high)
        aar[mid] &gt; key -&gt; binarySearchForRecursion(aar, key, low, mid - 1)
        else -&gt; mid
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表LinkedList]]></title>
        <id>https://wmszhe.github.io/post/linkedlist/</id>
        <link href="https://wmszhe.github.io/post/linkedlist/">
        </link>
        <updated>2019-07-04T06:40:09.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h2 id="链表-linkedlist">链表 LinkedList</h2>
<h3 id="定义">定义</h3>
<p>链表不需要一块连续的内存空间，它通过“指针”将一组<strong>零散的内存块</strong>串联起来使用</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/wmszhe/pichub/master/imgs/d5d5bee4be28326ba3c28373808a62cd.jpg" alt="" loading="lazy"></figure>
<p>其中，我们把内存块称为链表的“<strong>结点</strong>”。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。我们把这个记录下个结点地址的指针叫作<strong>后继指针 next</strong></p>
<h3 id="一-常见的链表结构">一. 常见的链表结构</h3>
<h4 id="1-单链表singly-linked-list">1. 单链表	Singly linked list</h4>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/wmszhe/pichub/master/imgs/b93e7ade9bb927baad1348d9a806ddeb.jpg" alt="" loading="lazy"></figure>
<p>有两个结点是比较特殊的，它们分别是第一个结点和最后一个结点。我们习惯性地把第一个结点叫作<strong>头结点</strong>，把最后一个结点叫作<strong>尾结点</strong>。其中，头结点用来记录链表的基地址。有了它，就可以遍历得到整条链表。而尾结点特殊的地方是：指针不是指向下一个结点，而是指向一个<strong>空地址 NULL</strong>，表示这是链表上最后一个结点</p>
<h5 id="11插入-删除-查找">1.1插入、删除、查找</h5>
<p>数组的插入、删除操作时，为了保持内存数据的连续性，需要做大量的数据搬移，所以时间复杂度是 O(n)。而在链表中插入或者删除一个数据，并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的。所以，在链表中插入和删除一个数据是非常快速的,时间复杂度是 O(1)。但是，链表要想随机访问第 k 个元素，就没有数组那么高效了。因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。时间复杂度是 O(n)</p>
<blockquote>
<p>插入删除时间复杂度O(1)</p>
</blockquote>
<blockquote>
<p>查找时间复杂度O(n)</p>
</blockquote>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/wmszhe/pichub/master/imgs/452e943788bdeea462d364389bd08a17.jpg" alt="" loading="lazy"></figure>
<h4 id="2-循环链表multiply-linked-list">2. 循环链表	Multiply linked list</h4>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/wmszhe/pichub/master/imgs/86cb7dc331ea958b0a108b911f38d155.jpg" alt="" loading="lazy"></figure>
<p><strong>循环链表是一种特殊的单链表</strong>。它跟单链表唯一的区别就在尾结点。单链表的尾结点指针指向空地址，表示这就是最后的结点了。而循环链表的尾结点指针是指向链表的头结点。</p>
<h4 id="3-双向链表doubly-linked-list">3. 双向链表	Doubly linked list</h4>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/wmszhe/pichub/master/imgs/cbc8ab20276e2f9312030c313a9ef70b.jpg" alt="" loading="lazy"></figure>
<p>单向链表只有一个方向，结点只有一个后继指针 next 指向后面的结点。而双向链表，顾名思义，它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。</p>
<p>双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。所以，如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样也带来了双向链表操作的灵活性。</p>
<h3 id="二-经典的链表应用场景">二. 经典的链表应用场景</h3>
<p>LRU 缓存淘汰算法</p>
<h5 id="21-实现原理">2.1 实现原理</h5>
<p>维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。</p>
<ol>
<li>如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。</li>
<li>如果此数据没有在缓存链表中，又可以分为两种情况：
<ul>
<li>如果此时缓存未满，则将此结点直接插入到链表的头部</li>
<li>如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部</li>
</ul>
</li>
</ol>
<h3 id="三-常见的链表算法">三. 常见的链表算法</h3>
<ol>
<li>单链表反转</li>
</ol>
<pre><code>fun main() {
    val note1 = SinglyLinkedNote(1)
    val note2 = SinglyLinkedNote(2)
    val note3 = SinglyLinkedNote(3)
    val note4 = SinglyLinkedNote(4)

    note1.next = note2
    note2.next = note3
    note3.next = note4

    printNode(reverseSingleLinkedList(note1))
}

/**
 * 单链表反转
 * @param node 单链表
 * @return 反转后的结果
 */
fun reverseSingleLinkedList(node: SinglyLinkedNote?): SinglyLinkedNote? {
    if (node?.next == null) {
        return node
    }
    val linkedNote = reverseSingleLinkedList(node.next)
    node.next?.next = node
    node.next = null
    return linkedNote
}

/**
 * 单链表
 */
class SinglyLinkedNote(var value: Int?) {
    var next: SinglyLinkedNote? = null
}

/**
 * 打印链表
 * @param data 链表
 * @return 链表数据 eg: { 1 2 3 4 }
 */
fun printNode(data: SinglyLinkedNote?) {
    var node: SinglyLinkedNote? = data
    val str: StringBuilder = StringBuilder(&quot;{ &quot;)
    while (node != null) {
        str.append(node.value).append(&quot; &quot;)
        node = node.next
    }
    str.append(&quot;}&quot;)
    println(str.toString())
}
</code></pre>
<ol start="2">
<li>链表中环的检测</li>
</ol>
<pre><code>
</code></pre>
<ol start="3">
<li>两个有序的链表合并</li>
</ol>
<pre><code>
</code></pre>
<ol start="4">
<li>删除链表倒数第 n 个结点</li>
</ol>
<pre><code>
</code></pre>
<ol start="5">
<li>求链表的中间结点</li>
</ol>
<pre><code>
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组Array]]></title>
        <id>https://wmszhe.github.io/post/array/</id>
        <link href="https://wmszhe.github.io/post/array/">
        </link>
        <updated>2019-07-04T06:32:33.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h3 id="数组-array">数组 Array</h3>
<blockquote>
<p>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</p>
</blockquote>
<ul>
<li>
<ol>
<li>线性表</li>
</ol>
</li>
<li>
<ol start="2">
<li>连续的内存空间和相同的数据结构</li>
</ol>
<blockquote>
<p>如果我们申请一个 100MB 大小的数组，当内存中没有连续的、足够大的存储空间时，即便内存的剩余总可用空间大于 100MB，仍然会申请失败。</p>
</blockquote>
</li>
</ul>
<h4 id="根据下标随机访问数组元素的方式">根据下标随机访问数组元素的方式</h4>
<p>一个长度为 10 的 int 类型的数组 int[] a = new int[10] , 计算机给数组 a[10]，分配了一块连续内存空间 1000～1039，其中，内存块的首地址为 base_address = 1000。</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/wmszhe/pichub/master/imgs/98df8e702b14096e7ee4a5141260cdc4.jpg" alt="" loading="lazy"></figure>
<p>通过下面的寻址公式，计算出该元素存储的内存地址：</p>
<blockquote>
<p>一维数组内存寻址：</p>
</blockquote>
<pre><code>a[i]_address = base_address + i * data_type_size
</code></pre>
<blockquote>
<p>二维数组内存寻址：</p>
</blockquote>
<p>对于 m * n 的数组，a [i][ j ] (i &lt; m,j &lt; n)的地址为：</p>
<pre><code>address = base_address + ( i * n + j) * type_size
</code></pre>
<p><mark><strong>数组是适合查找操作，但是查找的时间复杂度并不为 O(1)。即便是排好序的数组，用二分查找，时间复杂度也是 O(logn)。所以，正确的表述应该是，数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。</strong></mark></p>
<h4 id="插入删除低效原因">插入删除低效原因</h4>
<p>假设数组的长度为 n，现在，如果我们需要将一个数据插入到数组中的第 k 个位置。为了把第 k 个位置腾出来，给新来的数据，我们需要将第 k～n 这部分的元素都顺序地往后挪一位。</p>
<p>如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为 O(1)。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是 O(n)。 因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为 (1+2+…n)/n=O(n)。</p>
<blockquote>
<p>如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数组插入到第 k 个位置，为了避免大规模的数据搬移，我们还有一个简单的办法就是，直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置。</p>
</blockquote>
<p>eg:</p>
<p>假设数组 a[10] 中存储了如下 5 个元素：a，b，c，d，e。</p>
<p>我们现在需要将元素 x 插入到第 3 个位置。我们只需要将 c 放入到 a[5]，将 a[2] 赋值为 x 即可。最后，数组中的元素如下： a，b，x，d，e，c。</p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/wmszhe/pichub/master/imgs/3f70b4ad9069ec568a2caaddc231b7dc.jpg" alt="" loading="lazy"></figure>
<blockquote>
<p>删除时，在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。我们可以多次删除操作集中在一起执行</p>
</blockquote>
<p>eg:</p>
<p>数组 a[10] 中存储了 8 个元素：a，b，c，d，e，f，g，h。现在，我们要依次删除 a，b，c 三个元素</p>
<p>为了避免 d，e，f，g，h 这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。</p>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/wmszhe/pichub/master/imgs/b69b8c5dbf6248649ddab7d3e7cfd7e5.jpg" alt="" loading="lazy"></figure>
<h4 id="容器-arraylist">容器 ArrayList</h4>
<blockquote>
<p>针对数组类型，很多语言都提供了容器类，比如 Java 中的 ArrayList</p>
</blockquote>
<ul>
<li>优势：
<ul>
<li>
<ol>
<li>可以将很多数组操作的细节封装起来，比如前面提到的数组插入、删除数据时需要搬移其他数据等</li>
</ol>
</li>
<li>
<ol start="2">
<li>支持动态扩容 <mark><strong>不过，需要注意，因为扩容操作涉及内存申请和数据搬移，是比较耗时的。所以，如果事先能确定需要存储的数据大小，最好在创建 ArrayList 的时候事先指定数据大小</strong></mark></li>
</ol>
</li>
</ul>
</li>
<li>不足：
<ul>
<li>
<ol>
<li>Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。</li>
</ol>
</li>
<li>
<ol start="2">
<li>如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组</li>
</ol>
</li>
<li>要表示多维数组时，用数组往往会更加直观</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算法复杂度]]></title>
        <id>https://wmszhe.github.io/post/algorithm_complexity/</id>
        <link href="https://wmszhe.github.io/post/algorithm_complexity/">
        </link>
        <updated>2019-07-04T03:45:52.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="算法的复杂度">算法的复杂度</h1>
<blockquote>
<p>解决的是“快”和“省”的问题</p>
</blockquote>
<blockquote>
<p>参考： <a href="https://time.geekbang.org/column/article/40036">复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？</a></p>
</blockquote>
<blockquote>
<p>参考：<a href="https://time.geekbang.org/column/article/40447">复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度</a></p>
</blockquote>
<h2 id="时间复杂度">时间复杂度</h2>
<blockquote>
<p>时间复杂度的全称是<strong>渐进时间复杂度,表示算法的执行时间与数据规模之间的增长关系</strong>。</p>
</blockquote>
<h3 id="大-o-复杂度表示法">大 O 复杂度表示法</h3>
<blockquote>
<p>算法的执行效率，粗略地讲，就是算法代码执行的时间</p>
</blockquote>
<blockquote>
<p>算法的执行时间与每行代码的执行次数成正比，用T(n) = O(f(n))表示，其中T(n)表示算法执行总时间，f(n)表示每行代码执行总次数，而n往往表示数据的规模。</p>
</blockquote>
<p>比如如下代码，粗略估计执行时间</p>
<pre><code>int cal(int n) {
    int sum = 0;
    int i = 1;
    for (; i &lt;= n; ++i) {
        sum = sum + i;
    }
    return sum;
}
</code></pre>
<p>从 CPU 的角度来看，这段代码的每一行都执行着类似的操作：<strong>读数据-运算-写数据</strong>。尽管每行代码对应的 CPU 执行的个数、执行的时间都不一样，但是，我们这里只是粗略估计，所以可以假设每行代码执行的时间都一样，为 unit_time。在这个假设的基础之上，这段代码的总执行时间是多少呢</p>
<p>第 2、3 行代码分别需要 1 个 unit_time 的执行时间，第 4、5 行都运行了 n 遍，所以需要 <em>2n*unit_time</em> 的执行时间，所以这段代码总的执行时间就是 <strong>(2n+2)*unit_time</strong>。可以看出来，</p>
<blockquote>
<p><strong>所有代码的执行时间 T(n) 与每行代码的执行次数成正比</strong>。</p>
</blockquote>
<p>再看下这段代码</p>
<pre><code>int cal(int n) {
    int sum = 0;  // 1
    int i = 1;  // 1
    int j = 1;  // 1
    for (; i &lt;= n; ++i) {  // n
        j = 1; // n
        for (; j &lt;= n; ++j) {  // n^2
            sum = sum + i * j;  // n^2
        }
    }
}
</code></pre>
<p>可以得出，复杂度为T(n) = (2n^2+2n+3)*unit_time。</p>
<p>尽管我们不知道 unit_time 的具体值，但是通过这两段代码执行时间的推导过程，我们可以得到一个非常重要的规律，那就是，</p>
<blockquote>
<p><strong>所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比</strong></p>
</blockquote>
<p><strong>总结为：</strong></p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/wmszhe/pichub/master/imgs/22900968aa2b190072c985a08b0e92ef.png" alt="" loading="lazy"></figure>
<p>T(n)表示代码执行的时间；n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。</p>
<p>所以，第一个例子中的 T(n) = O(2n+2)，第二个例子中的 T(n) = O(2n^2+2n+3)。这就是<strong>大 O 时间复杂度表示法</strong>。大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示<strong>代码执行时间随数据规模增长的变化趋势</strong>，所以，也叫作<strong>渐进时间复杂度</strong>（asymptotic time complexity），简称<strong>时间复杂度</strong></p>
<p>当 n 很大时，你可以把它想象成 10000、100000。而<strong>公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略</strong>。我们只需要记录一个最大量级就可以了，如果用大 O 表示法表示刚讲的那两段代码的时间复杂度，就可以记为：T(n) = O(n)； T(n) = O(n^2)。</p>
<h3 id="如何分析时间复杂度">如何分析时间复杂度</h3>
<ul>
<li>
<ol>
<li>只关注循环执行次数最多的一段代码</li>
</ol>
<blockquote>
<p>大 O 这种复杂度表示方法只是表示一种变化趋势。<strong>我们通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。所以，我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了</strong>。这段核心代码执行次数的 n 的量级，就是整段要分析代码的时间复杂度。</p>
</blockquote>
<p>第一段代码，其中第 2、3 行代码都是常量级的执行时间，与 n 的大小无关，所以对于复杂度并没有影响。循环执行次数最多的是第 4、5 行代码，所以这块代码要重点分析。前面我们也讲过，这两行代码被执行了 n 次，所以总的时间复杂度就是 O(n)。</p>
<p>即：第一段代码，时间复杂度为O(n), 第二段代码，时间复杂度为O(n^2)</p>
</li>
<li>
<ol start="2">
<li>加法法则：总复杂度等于量级最大的那段代码的复杂度</li>
</ol>
<pre><code>int cal(int n) {
    int sum_1 = 0;
    int p = 1;
    for (; p &lt; 100; ++p) {
        sum_1 = sum_1 + p;
    }

    int sum_2 = 0;
    int q = 1;
    for (; q &lt; n; ++q) {
        sum_2 = sum_2 + q;
    }

    int sum_3 = 0;
    int i = 1;
    int j = 1;
    for (; i &lt;= n; ++i) {
        j = 1;
        for (; j &lt;= n; ++j) {
            sum_3 = sum_3 + i * j;
        }
    }

    return sum_1 + sum_2 + sum_3;
}
</code></pre>
<blockquote>
<p>上述代码3部分后2部分时间复杂度分别为O(n), O(n<sup>2)，我们取其中最大的量级,即O(n</sup>2).</p>
</blockquote>
<p>抽象成公式,为：</p>
<blockquote>
<p>如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n))).</p>
</blockquote>
</li>
<li>
<p>3.乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</p>
<blockquote>
<p>如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)*T2(n)=O(f(n))*O(g(n))=O(f(n)*g(n)).</p>
</blockquote>
<pre><code>int cal(int n) {
    int ret = 0;
    int i = 1;
    for (; i &lt; n; ++i) {
        ret = ret + f(i);
    }
}

int f(int n) {
    int sum = 0;
    int i = 1;
    for (; i &lt; n; ++i) {
        sum = sum + i;
    }
    return sum;
}
</code></pre>
<blockquote>
<p>T(n) = T1(n) * T2(n) = O(n*n) = O(n^2)</p>
</blockquote>
</li>
</ul>
<h3 id="几种常见的时间复杂度">几种常见的时间复杂度</h3>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/wmszhe/pichub/master/imgs/3723793cc5c810e9d5b06bc95325bf0a.jpg" alt="" loading="lazy"></figure>
<p>对于上述罗列的复杂度量级，我们可以粗略地分为两类，<strong>多项式量级</strong>和<strong>非多项式量级</strong>。其中，非多项式量级只有两个：O(2^n) 和 O(n!)。</p>
<ul>
<li>
<ol>
<li>O(1)</li>
</ol>
<p>首先你必须明确一个概念，O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。比如这段代码，即便有 3 行，它的时间复杂度也是 O(1），而不是 O(3)。</p>
<pre><code>int i = 8;
int j = 6;
int sum = i + j;
</code></pre>
<p>稍微总结一下，只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1)。或者说，</p>
<blockquote>
<p><strong>一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)</strong></p>
</blockquote>
</li>
<li>
<ol start="2">
<li>O(logn)、O(nlogn)</li>
</ol>
<p>对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度</p>
<pre><code>i = 1;
while (i &lt;= n) {
    i = i * 2;
}
</code></pre>
<p>从代码中可以看出，变量 i 的值从 1 开始取，每循环一次就乘以 2。当大于 n 时，循环结束。还记得我们高中学过的等比数列吗？实际上，变量 i 的取值就是一个等比数列。如果我把它一个一个列出来，就应该是这个样子的</p>
<blockquote>
<p>2^0 2^1 2^2 ... (2^x=n)</p>
</blockquote>
<p>所以，我们只要知道 x 值是多少，就知道这行代码执行的次数了。通过 2^x=n 求解x=log<sub>2</sub>n，所以，这段代码的时间复杂度就是 O(log<sub>2</sub>n)</p>
<pre><code>i = 1;
while (i &lt;= n)  {
    i = i * 3;
}
</code></pre>
<p>根据刚刚的思路，很简单就能看出来，这段代码的时间复杂度为 O(log<sub>3</sub>n)。</p>
<p>实际上，不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 O(logn)。为什么呢？</p>
<p>我们知道，对数之间是可以互相转换的，log<sub>3</sub>n 就等于 log<sub>3</sub>2 * log<sub>2</sub>n，所以 O(log<sub>3</sub>n) = O(C *  log<sub>2</sub>n)，其中 C=log<sub>3</sub>2 是一个常量。基于我们前面的一个理论：<strong>在采用大 O 标记复杂度的时候，可以忽略系数，即 O(Cf(n)) = O(f(n))</strong>。所以，O(log<sub>2</sub>n) 就等于 O(log<sub>3</sub>n)。因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 O(logn)</p>
<blockquote>
<p>换底公式</p>
</blockquote>
<blockquote>
<p>log<sub>3</sub>2 * log<sub>2</sub>n =  log<sub>3</sub>2 * (log<sub>3</sub>n / log<sub>3</sub>2) = log<sub>3</sub>n</p>
</blockquote>
<p>如果你理解O(logn)，那 O(nlogn) 就很容易理解了。根据乘法法则，如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。而且，O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 O(nlogn)。</p>
</li>
<li>
<ol start="3">
<li>O(m+n)、O(m*n)</li>
</ol>
<p>不一样的时间复杂度，代码的复杂度<strong>由两个数据的规模</strong>来决定。</p>
<pre><code>int cal(int m, int n) {
    int sum_1 = 0;
    int i = 1;
    for (; i &lt; m; ++i) {
      sum_1 = sum_1 + i;
    }
  
    int sum_2 = 0;
    int j = 1;
    for (; j &lt; n; ++j) {
      sum_2 = sum_2 + j;
    }
  
    return sum_1 + sum_2;
}
</code></pre>
<p>从代码中可以看出，m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n)</p>
<blockquote>
<p>针对这种情况，原来的加法法则就不正确了，我们需要将加法规则改为：T1(m) + T2(n) = O(f(m) + g(n))。但是乘法法则继续有效：T1(m)*T2(n) = O(f(m) * f(n))。</p>
</blockquote>
</li>
</ul>
<h3 id="稍微复杂一点的复杂度分析">稍微复杂一点的复杂度分析</h3>
<blockquote>
<p>为了表示代码在不同情况下的不同时间复杂度，我们需要引入新的概念</p>
</blockquote>
<ul>
<li>
<ol>
<li>最好情况时间复杂度(best case time complexity)</li>
</ol>
<blockquote>
<p>在最理想的情况下，执行这段代码的时间复杂度</p>
</blockquote>
</li>
<li>
<ol start="2">
<li>最坏情况时间复杂度(worst case time complexity)</li>
</ol>
<blockquote>
<p>在最糟糕的情况下，执行这段代码的时间复杂度</p>
</blockquote>
</li>
<li>
<ol start="3">
<li>平均时间复杂度(average case time complexity)</li>
</ol>
<blockquote>
<p>最好情况时间复杂度和最坏情况时间复杂度对应的都是极端情况下的代码复杂度，发生的概率其实并不大。为了更好地表示平均情况下的复杂度，我们需要引入另一个概念：平均情况时间复杂度，后面我简称为平均时间复杂度。</p>
</blockquote>
</li>
<li>
<ol start="4">
<li>均摊时间复杂度(amortized time complexity)</li>
</ol>
</li>
</ul>
<h4 id="最好-最坏情况时间复杂度">最好、最坏情况时间复杂度</h4>
<pre><code>// n 表示数组 array 的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i &lt; n; ++i) {
    if (array[i] == x) {
       pos = i;
       break;
    }
  }
  return pos;
}
</code></pre>
<p>如果数组中第一个元素正好是要查找的变量 x，那就不需要继续遍历剩下的 n-1 个数据了，那时间复杂度就是 O(1)。但如果数组中不存在变量 x，那我们就需要把整个数组都遍历一遍，时间复杂度就成了 O(n)。所以，不同的情况下，这段代码的时间复杂度是不一样的。</p>
<h4 id="平均时间复杂度">平均时间复杂度</h4>
<p>以上面的代码为例，要查找x在数组中的位置，有2种情况，第一种，x在数组中，第二种，x不在数组中。</p>
<p>每种情况下，查找总次数为 1+2+3+..+n+n（第一种情况数量为1+2+3+..+n,第二种情况为n）</p>
<p>一共有n+1种情况</p>
<p>所以，平均时间复杂度为(1+2+3+..+n+n)/(n+1) = (n*(n+1)/2 + 2n/2)/(n+1) = (n*(n+3))/(2*(n+1))</p>
<p>省略掉系数、低阶、常量，所以，这个公式简化之后，得到的平均时间复杂度就是 O(n)。</p>
<p><strong>但是</strong></p>
<p>n+1 种情况，出现的概率并不是一样的</p>
<p>要查找的变量 x，要么在数组里，要么就不在数组里。在数组中与不在数组中的概率都为 1/2。另外，要查找的数据出现在 0～n-1 这 n 个位置的概率也是一样的，为 1/n。所以，根据概率乘法法则，要查找的数据出现在 0～n-1 中任意位置的概率就是 1/(2n)</p>
<p>所以，时间复杂度为:</p>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/wmszhe/pichub/master/imgs/36c0aabdac69032f8a43368f5e90c67f.jpg" alt="" loading="lazy"></figure>
<p><mark><strong>即，时间复杂度为O(n)</strong></mark></p>
<h4 id="均摊时间复杂度">均摊时间复杂度</h4>
<pre><code>// array 表示一个长度为 n 的数组
// 代码中的 array.length 就等于 n
int[] array = new int[n];
int count = 0;

void insert(int val) {
   if (count == array.length) {
      int sum = 0;
      for (int i = 0; i &lt; array.length; ++i) {
         sum = sum + array[i];
      }
      array[0] = sum;
      count = 1;
   }
   array[count] = val;
   ++count;
}
</code></pre>
<p>这段代码实现了一个往数组中插入数据的功能。当数组满了之后，也就是代码中的 count == array.length 时，我们用 for 循环遍历数组求和，将求和之后的 sum 值放到数组的第一个位置，然后再将新的数据插入。但如果数组一开始就有空闲空间，则直接将数据插入数组。</p>
<p>最理想的情况下，数组中有空闲空间，我们只需要将数据插入到数组下标为 count 的位置就可以了，所以最好情况时间复杂度为 O(1)。最坏的情况下，数组中没有空闲空间了，我们需要先做一次数组的遍历求和，然后再将数据插入，所以最坏情况时间复杂度为 O(n)。</p>
<p>假设数组的长度是 n，根据数据插入的位置的不同，我们可以分为 n 种情况，每种情况的时间复杂度是 O(1)。除此之外，还有一种“额外”的情况，就是在数组没有空闲空间时插入一个数据，这个时候的时间复杂度是 O(n)。而且，这 n+1 种情况发生的概率一样，都是 1/(n+1)。所以，根据加权平均的计算方法，我们求得的平均时间复杂度就是：</p>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/wmszhe/pichub/master/imgs/6df62366a60336d9de3bc34f488d8bed.jpg" alt="" loading="lazy"></figure>
<p>至此为止，前面的最好、最坏、平均时间复杂度的计算，理解起来应该都没有问题。但是这个例子里的平均复杂度分析其实并不需要这么复杂，不需要引入概率论的知识。这是为什么呢？我们先来对比一下这个 insert() 的例子和前面那个 find() 的例子，你就会发现这两者有很大差别。</p>
<p>首先，find() 函数在极端情况下，复杂度才为 O(1)。但 insert() 在大部分情况下，时间复杂度都为 O(1)。只有个别情况下，复杂度才比较高，为 O(n)。这是 insert()<strong>第一个</strong>区别于 find() 的地方。</p>
<p>所以，针对这样一种特殊场景的复杂度分析，我们并不需要像之前讲平均复杂度分析方法那样，找出所有的输入情况及相应的发生概率，然后再计算加权平均值。</p>
<p>那究竟如何使用摊还分析法来分析算法的均摊时间复杂度呢？</p>
<p>继续看在数组中插入数据的这个例子。每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1)。这就是均摊分析的大致思路</p>
<p>对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。</p>
<h2 id="空间复杂度">空间复杂度</h2>
<blockquote>
<p>空间复杂度全称就是<strong>渐进空间复杂度（asymptotic space complexity,表示算法的存储空间与数据规模之间的增长关系</strong></p>
</blockquote>
<h3 id="空间复杂度分析">空间复杂度分析</h3>
<pre><code>void print(int n) {
  int i = 0;
  int[] a = new int[n];
  for (i; i &lt;n; ++i) {
    a[i] = i * i;
  }

  for (i = n-1; i &gt;= 0; --i) {
    print out a[i]
  }
}
</code></pre>
<p>跟时间复杂度分析一样，我们可以看到，第 2 行代码中，我们申请了一个空间存储变量 i，但是它是常量阶的，跟数据规模 n 没有关系，所以我们可以忽略。第 3 行申请了一个大小为 n 的 int 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)</p>
<h3 id="几种常见的空间复杂度">几种常见的空间复杂度</h3>
<ul>
<li>
<ol>
<li>O(1)</li>
</ol>
</li>
<li>
<ol start="2">
<li>O(n)</li>
</ol>
</li>
<li>
<ol start="3">
<li>O(n<sup>2</sup>)</li>
</ol>
</li>
</ul>
<h2 id="总结">总结</h2>
<p>复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n<sup>2</sup> )。</p>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/wmszhe/pichub/master/imgs/497a3f120b7debee07dc0d03984faf04.jpg" alt="" loading="lazy"></figure>
<h2 id="demo">Demo</h2>
<pre><code>// 全局变量，大小为 10 的数组 array，长度 len，下标 i。
int array[] = new int[10]; 
int len = 10;
int i = 0;

// 往数组中添加一个元素
void add(int element) {
   if (i &gt;= len) { // 数组空间不够了
     // 重新申请一个 2 倍大小的数组空间
     int new_array[] = new int[len*2];
     // 把原来 array 数组中的数据依次 copy 到 new_array
     for (int j = 0; j &lt; len; ++j) {
       new_array[j] = array[j];
     }
     // new_array 复制给 array，array 现在大小就是 2 倍 len 了
     array = new_array;
     len = 2 * len;
   }
   // 将 element 放到下标为 i 的位置，下标 i 加一
   array[i] = element;
   ++i;
}
</code></pre>
<p>当i&lt; len时, 即 i = 0,1,2,...,n-1的时候，for循环不走，所以这n次的时间复杂度都是O(1);</p>
<p>当i &gt;= len时, 即 i = n的时候，for循环进行数组的copy，所以只有这1次的时间复杂度是O(n);</p>
<p>由此可知:</p>
<p>该算法的最好情况时间复杂度(best case time complexity)为O(1);</p>
<p>最坏情况时间复杂度(worst case time complexity)为O(n);</p>
<p>平均情况时间复杂度(average case time complexity):</p>
<p>第一种计算方式: (1+1+...+1+n)/(n+1) = 2n/(n+1) 【注: 式子中1+1+...+1中有n个1】,所以平均复杂度为O(1);</p>
<p>第二种计算方式(加权平均法，又称期望): 1*(1/n+1)+1*(1/n+1)+...+1*(1/n+1)+n*(1/(n+1))=1，所以加权平均时间复杂度为O(1);</p>
<p>第三种计算方式(均摊时间复杂度): 前n个操作复杂度都是O(1)，第n+1次操作的复杂度是O(n)，所以把最后一次的复杂度分摊到前n次上，那么均摊下来每次操作的复杂度为O(1)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构和算法]]></title>
        <id>https://wmszhe.github.io/post/data_structures_and_algorithm/</id>
        <link href="https://wmszhe.github.io/post/data_structures_and_algorithm/">
        </link>
        <updated>2019-07-04T03:20:13.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h2 id="数据结构和算法">数据结构和算法</h2>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/wmszhe/pichub/master/imgs/913e0ababe43a2d57267df5c5f0832a7.jpg" alt="" loading="lazy"></figure>
<h3 id="线性表和非线性表">线性表和非线性表</h3>
<ul>
<li>
<ol>
<li>线性表（Linear List）。顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构<br>
<img src="https://raw.githubusercontent.com/wmszhe/pichub/master/imgs/b6b71ec46935130dff5c4b62cf273477.jpg" alt="" loading="lazy"></li>
</ol>
</li>
<li>
<ol start="2">
<li>非线性表，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。<br>
<img src="https://raw.githubusercontent.com/wmszhe/pichub/master/imgs/6ebf42641b5f98f912d36f6bf86f6569.jpg" alt="" loading="lazy"></li>
</ol>
</li>
</ul>
<h3 id="常见的策略">常见的策略</h3>
<ul>
<li>先进先出策略 FIFO（First In，First Out）</li>
<li>最少使用策略 LFU（Least Frequently Used）</li>
<li>最近最少使用策略 LRU（Least Recently Used）</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android性能优化]]></title>
        <id>https://wmszhe.github.io/post/android_optimize/</id>
        <link href="https://wmszhe.github.io/post/android_optimize/">
        </link>
        <updated>2019-06-24T09:17:17.000Z</updated>
        <summary type="html"><![CDATA[<p>Android性能优化，一些性能优化方式。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Android性能优化，一些性能优化方式。</p>
<!-- more -->
<h2 id="删除多余依赖项">删除多余依赖项</h2>
<ol>
<li>
<p>查找多余依赖</p>
<blockquote>
<p>菜单栏 -&gt; Analyze -&gt; Run Inspection Name -&gt; 输入unused library -&gt; 回车 -&gt; 查看分析结果</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/wmszhe/pichub/master/imgs/1561599539057.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>查看module依赖</p>
<blockquote>
<p>使用gradle，依次确认各个module实际依赖情况</p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/wmszhe/pichub/master/imgs/1561599225931.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/wmszhe/pichub/master/imgs/1561368142795.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>排除多余依赖</p>
<blockquote>
<p>根据InspectionResult结果和dependencies结果，排除多余依赖项</p>
</blockquote>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/wmszhe/pichub/master/imgs/1561368152549.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/wmszhe/pichub/master/imgs/1561599326748.png" alt="" loading="lazy"></figure>
</li>
</ol>
<h2 id="删除多余的资源文件">删除多余的资源文件</h2>
<blockquote>
<p>菜单栏 -&gt; Analyze -&gt; Run Inspection Name -&gt; 输入unused Resources -&gt; 回车 -&gt; 查看分析结果 -&gt; 删除</p>
</blockquote>
<figure data-type="image" tabindex="6"><img src="https://raw.githubusercontent.com/wmszhe/pichub/master/imgs/1561629719716.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Dart一些特殊的特性]]></title>
        <id>https://wmszhe.github.io/post/dart_features/</id>
        <link href="https://wmszhe.github.io/post/dart_features/">
        </link>
        <updated>2019-06-21T02:21:04.000Z</updated>
        <summary type="html"><![CDATA[<p>Dart一些特殊的特性，比较容易忘记和混淆的</p>
]]></summary>
        <content type="html"><![CDATA[<p>Dart一些特殊的特性，比较容易忘记和混淆的</p>
<!-- more -->
<h3 id="参数加">参数加{}</h3>
<blockquote>
<p>在调用函数传递参数时，指定参数名</p>
</blockquote>
<pre><code>void sayHello({String name, String msg}){
    
}
sayHello(name: &quot;abc&quot;, msg: &quot;hello&quot;);
</code></pre>
<h3 id="可选参数">可选参数</h3>
<blockquote>
<p>可选的参数，在调用时可以不传</p>
</blockquote>
<blockquote>
<p>通过位置来确定实参和形参的对应关系的</p>
</blockquote>
<blockquote>
<p>参考： https://blog.csdn.net/xlh1191860939/article/details/87895616</p>
</blockquote>
<pre><code>String say(String from, String msg, [String device, String time]) {
 
    var result = &quot;$from says $msg&quot;;
 
    if (device != null) {
      result = &quot;$result with a $device&quot;;
    }
 
    if (time != null) {
      result = &quot;$result at $time&quot;;
    }
 
    return result;
}
 
void main(){
    print(say(&quot;david&quot;, &quot;hello&quot;, &quot;mobile&quot;, &quot;2019.2.29.20:08:08&quot;));
    // david says hello with a mobile at 2019.2.29.20:08:08
    print(say(&quot;david&quot;, &quot;hello&quot;, &quot;2019.2.29.20:08:08&quot;, &quot;mobile&quot;));
    // david says hello with a 2019.2.29.20:08:08 at mobile
    print(say(&quot;david&quot;, &quot;hello&quot;));
    // david says hello
}
</code></pre>
<h3 id="">??=</h3>
<blockquote>
<p>仅在变量为null时赋值，使用??=运算符</p>
</blockquote>
<pre><code>// 如果b为空，则将值分配给b；否则，b保持不变
b ??= value;
</code></pre>
<h3 id="-2">?.</h3>
<blockquote>
<p>eg : foo?.bar</p>
</blockquote>
<blockquote>
<p>foo可以为空,foo为空时返回空，否则返回bar</p>
</blockquote>
<pre><code>foo?.bar

====等同于====

if(foo != null) {
    return bar;
} else {
    return null;
}
</code></pre>
<h3 id="和-~">/ 和 ~/</h3>
<blockquote>
<p>/ 除</p>
</blockquote>
<blockquote>
<p>~/ 返回一个整数值的除法</p>
</blockquote>
<pre><code>assert(5 / 2 == 2.5); // 结果是double类型
assert(5 ~/ 2 == 2); // 结果是一个整数
</code></pre>
<h3 id="print">print</h3>
<blockquote>
<p>打印重复内容，可以使用*</p>
</blockquote>
<blockquote>
<p>如果要打印d.e，外层添加{}</p>
</blockquote>
<pre><code>print(&quot;abc&quot;);
print(&quot;abc $d&quot;);
print(&quot;abc ${d.e}&quot;);
print(&quot;abc&quot; * 10); // 打印10次abc
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[FlutterUI相关]]></title>
        <id>https://wmszhe.github.io/post/flutter_ui/</id>
        <link href="https://wmszhe.github.io/post/flutter_ui/">
        </link>
        <updated>2019-06-19T08:48:52.000Z</updated>
        <summary type="html"><![CDATA[<p>获取屏幕尺寸，widget尺寸和位置</p>
]]></summary>
        <content type="html"><![CDATA[<p>获取屏幕尺寸，widget尺寸和位置</p>
<!-- more --> 
<h3 id="屏幕尺寸通过window相关方法获取">屏幕尺寸通过window相关方法获取</h3>
<h5 id="屏幕尺寸物理像素-px">屏幕尺寸（物理像素 px）</h5>
<pre><code>window.physicalSize -&gt; Size(960.0, 720.0)
</code></pre>
<h5 id="屏幕密度">屏幕密度</h5>
<pre><code>window.devicePixelRatio -&gt; 2.0
</code></pre>
<h3 id="屏幕尺寸通过mediaquery相关方法获取">屏幕尺寸通过MediaQuery相关方法获取</h3>
<blockquote>
<p>MediaQuery最终还是调用的window方法</p>
</blockquote>
<h5 id="屏幕尺寸逻辑像素-dp">屏幕尺寸（逻辑像素 dp）</h5>
<blockquote>
<p>MediaQuery.of(context).size获取的是逻辑像素，物理像素/屏幕密度</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/wmszhe/pichub/master/imgs/1560934244332.png" alt="" loading="lazy"></figure>
<pre><code>MediaQuery.of(context).size -&gt; Size(480.0, 360.0)
</code></pre>
<h5 id="屏幕密度-2">屏幕密度</h5>
<pre><code>MediaQuery.of(context).devicePixelRatio -&gt; 2.0
</code></pre>
<h5 id="横竖屏">横竖屏</h5>
<blockquote>
<p>横竖屏是根据宽高判断的</p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/wmszhe/pichub/master/imgs/1560934253781.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/wmszhe/pichub/master/imgs/1560934262800.png" alt="" loading="lazy"></figure>
<pre><code>MediaQuery.of(context).orientation -&gt; Orientation.landscape
</code></pre>
<h3 id="widget大小和位置">Widget大小和位置</h3>
<h4 id="可以通过globalkey获取">可以通过GlobalKey获取</h4>
<blockquote>
<p>参考：<a href="https://medium.com/@diegoveloper/flutter-widget-size-and-position-b0a9ffed9407">Flutter : Widget Size and Position</a></p>
</blockquote>
<blockquote>
<p>需要对每个widget创建一个GlobalKey</p>
</blockquote>
<pre><code>GlobalKey _keyRed = GlobalKey();
</code></pre>
<pre><code>key: _keyRed,
</code></pre>
<pre><code>RenderBox findRenderObject = _keyRed.currentContext.findRenderObject();
var offset = findRenderObject.localToGlobal(Offset.zero);
print(&quot;---icon offset : $offset&quot;);

var size = _keyRed.currentContext.size;
print(&quot;---icon size : $size&quot;);
</code></pre>
<h4 id="从context对象中获取">从context对象中获取</h4>
<h5 id="自定义widget时可以从build方法中的context中获取">自定义Widget时，可以从build方法中的context中获取</h5>
<pre><code>class CustomIcon extends Icon {
  CustomIcon(IconData icon) : super(icon);

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      child: Icon(icon),
      onTap: () {
        RenderBox findRenderObject = context.findRenderObject();
        var offset = findRenderObject.localToGlobal(Offset.zero);
        print(&quot;icon offset : $offset&quot;);

        var size = context.size;
        print(&quot;icon size : $size&quot;);
      },
    );
  }
}
</code></pre>
<h5 id="直接使用系统widget时使用layoutbuilderlayoutbuilder提供了build方法中含有context对象">直接使用系统widget时，使用LayoutBuilder，LayoutBuilder提供了build方法中含有context对象</h5>
<pre><code>class HomePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Row(
        children: &lt;Widget&gt;[
          LayoutBuilder(
            builder: (context, constraints) {
              return GestureDetector(
                child: MyIcon(Icons.dashboard),
                onTap: (){
                  RenderBox findRenderObject = context.findRenderObject();
                  var offset = findRenderObject.localToGlobal(Offset.zero);
                  print(&quot;---icon offset : $offset&quot;);

                  var size = context.size;
                  print(&quot;---icon size : $size&quot;);
                },
              );
            },
          ),
          MyIcon(Icons.ac_unit),
        ],
      ),
    );
  }
}
</code></pre>
<h4 id="在widget-build完成之后执行操作">在widget build完成之后，执行操作</h4>
<blockquote>
<p>在return一个widget之前，context为null，如果想要在build之后，立即获取一些属性，可以使用WidgetsBinding.instance.addPostFrameCallback((_) =&gt; afterBuild(context));</p>
</blockquote>
<pre><code>class HomePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Row(
        children: &lt;Widget&gt;[
          LayoutBuilder(
            builder: (context, constraints) {
              WidgetsBinding.instance.addPostFrameCallback((_) =&gt; afterBuild(context));
              return Container(
                child: MyIcon(Icons.dashboard),
              );
            },
          ),
        ],
      ),
    );
  }

  afterBuild(BuildContext context) {
    RenderBox findRenderObject = context.findRenderObject();
    var offset = findRenderObject.localToGlobal(Offset.zero);
    print(&quot;---icon offset : $offset&quot;);

    var size = context.size;
    print(&quot;---icon size : $size&quot;);
  }
}
</code></pre>
<h3 id="软键盘相关">软键盘相关</h3>
<h4 id="显示隐藏软键盘">显示隐藏软键盘</h4>
<ol>
<li>通过焦点方式</li>
</ol>
<pre><code>// 隐藏
FocusScope.of(context).requestFocus(FocusNode())
// 显示
FocusScope.of(context).autofocus(_focusNode)
</code></pre>
<ol start="2">
<li>通过channel方式</li>
</ol>
<pre><code>// 显示
SystemChannels.textInput.invokeMethod('TextInput.show');
// 隐藏
SystemChannels.textInput.invokeMethod('TextInput.hide');
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[FLutter编译桌面端app]]></title>
        <id>https://wmszhe.github.io/post/flutter_desktop/</id>
        <link href="https://wmszhe.github.io/post/flutter_desktop/">
        </link>
        <updated>2019-06-18T09:35:45.000Z</updated>
        <summary type="html"><![CDATA[<p>使用<a href="https://github.com/google/flutter-desktop-embedding">flutter-desktop-embedding</a>编译适用于macos、windows、linux桌面端的app</p>
]]></summary>
        <content type="html"><![CDATA[<p>使用<a href="https://github.com/google/flutter-desktop-embedding">flutter-desktop-embedding</a>编译适用于macos、windows、linux桌面端的app</p>
<!-- more --> 
<h4 id="流程">流程</h4>
<ol>
<li>
<p>配置flutter环境，必须在master分支</p>
<pre><code>flutter channel master
flutter upgrade
</code></pre>
</li>
<li>
<p>clone flutter-desktop-embedding</p>
<pre><code>git clone git@github.com:google/flutter-desktop-embedding.git
</code></pre>
</li>
<li>
<p>复制flutter-desktop-embedding/example到自己的开发目录下,重命名为flutter_desktop</p>
<blockquote>
<p>目前不支持flutter create直接创建desktop项目，只能复制出example项目修改</p>
</blockquote>
</li>
<li>
<p>开启ENABLE_FLUTTER_DESKTOP</p>
<ul>
<li><strong>一次性，每次打开项目都要执行</strong><pre><code>命令行中 export ENABLE_FLUTTER_DESKTOP=true
</code></pre>
</li>
<li><strong>永久</strong><pre><code>.zshrc中添加 export ENABLE_FLUTTER_DESKTOP=true
</code></pre>
</li>
<li><strong>如果使用的是vscode</strong><pre><code>打开设置(json)，添加
&quot;dart.env&quot;: {
    &quot;ENABLE_FLUTTER_DESKTOP&quot;: true,
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>更新依赖</p>
<pre><code>flutter packages get
</code></pre>
</li>
<li>
<p>flutter run,即可看到demo项目		<br>
<code>flutter run</code><br>
<img src="https://raw.githubusercontent.com/wmszhe/pichub/master/imgs/1560851493604.png" alt="" loading="lazy"></p>
</li>
<li>
<p>使用文本编辑器打开flutter_desktop项目，在lib目录下编写自己的代码<br>
<img src="https://raw.githubusercontent.com/wmszhe/pichub/master/imgs/1560850644118.png" alt="" loading="lazy"></p>
</li>
<li>
<p>over!</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git]]></title>
        <id>https://wmszhe.github.io/post/git/</id>
        <link href="https://wmszhe.github.io/post/git/">
        </link>
        <updated>2019-06-15T12:19:24.000Z</updated>
        <summary type="html"><![CDATA[<p>Git相关,常用Git命令...</p>
]]></summary>
        <content type="html"><![CDATA[<p>Git相关,常用Git命令...</p>
<!-- more --> 
<h3 id="ssh">SSH</h3>
<pre><code>1. 生成SSH秘钥，秘钥名字最好便于识别，例如用自己的名字,[keyname]=name
    ssh-keygen -f ~/.ssh/[keyname]
2. 查看公钥信息
    cat ~/.ssh/[keyname].pub
3. 将公钥信息粘贴到gerrit上，打开gerrit点击右上角的登录，使用员工账号与密码登录，登录后点击gerrit右上角用户名，点击弹出框左下的Settings,选择左侧的SSH Public Keys，将公钥信息粘贴进去点击Add。
4. 将私钥加到ssh-agent
    ssh-agent bash
    ssh-add ~/.ssh/[keyname]
5. 配置git
    git config --global user.name [fullname] 这个名字建议写全名
    git config --global user.email [email]  这个email填写你的邮箱
    git config --global color.ui true
    git config --global gui.encoding utf-8

</code></pre>
<h3 id="设置git全局设置">设置git全局设置：</h3>
<pre><code>git config --global user.name &quot;your_name&quot; 
git config --global user.email  &quot;your_email&quot;
</code></pre>
<h3 id="需要取消git的全局设置">需要取消git的全局设置:</h3>
<pre><code>git config --global --unset user.name
git config --global --unset user.email
</code></pre>
<h3 id="针对每个项目单独设置用户名和邮箱设置方法如下">针对每个项目，单独设置用户名和邮箱，设置方法如下：</h3>
<pre><code>git config user.name &quot;your_name&quot; 
git config user.email &quot;your_email&quot;
</code></pre>
<h3 id="测试连接">测试连接</h3>
<pre><code>ssh -T git@github.com
ssh -T git@192.168.1.2
</code></pre>
<h3 id="gitignore无效的解决方法">.gitignore无效的解决方法</h3>
<p>在项目文件夹下打开git bash，执行</p>
<pre><code>git rm -r --cached .DS_Store 这句代码的意思就是解除跟踪DS_Store，清缓存
// git rm -r --cached . 解除跟踪所有文件
git add .
git commit -m 'update .gitignore'
</code></pre>
<h3 id="init">init</h3>
<pre><code>git init
git add .
git commit -m &quot;init&quot;
</code></pre>
<h3 id="init后传至git仓库">init后传至git仓库</h3>
<pre><code>git remote add origin git@github.com:wmszhe/PythonTools.git
git push -u origin master
</code></pre>
<h3 id="日志">日志</h3>
<h5 id="1查询日志">1.查询日志</h5>
<pre><code>git log
</code></pre>
<h5 id="2查指定文件的提交日志">2.查指定文件的提交日志</h5>
<pre><code>1. 查看日志记录
git log --pretty=oneline .gitignore

2. 使用git show查看具体日志 --&gt; git show &lt;git提交版本号&gt; &lt;文件名&gt;
git show 03bb009eb06b16c62155206b0e5724b532820efd .gitignore
</code></pre>
<h5 id="3查询某个人的提交日志">3.查询某个人的提交日志</h5>
<pre><code>git log --author=&quot;author&quot;
</code></pre>
<h3 id="clone">clone</h3>
<pre><code>git clone https://github.com/CharonChui/AndroidNote.git __AndroidNote(自定义的文件夹名)
git clone ssh://zhe.wang@192.168.0.119:29418/adclient -b gte
</code></pre>
<h3 id="clone-depth">clone --depth</h3>
<p>指定克隆深度,为1即表示只克隆最近一次commit.</p>
<pre><code>git clone xxx --depth 1
</code></pre>
<p>如果我们之后要把之前的历史重新再 pull 下来</p>
<pre><code>// 将浅克隆转换为完整克隆
git pull --unshallow
git fetch --unshallow
</code></pre>
<h3 id="安装hook目的是在提交信息中自动创建-change-id-标签">安装hook,目的是在提交信息中自动创建 'Change-Id:' 标签</h3>
<pre><code>cd adclient
scp -p -P 29418 zhe.wang@192.168.0.119:hooks/commit-msg .git/hooks/
</code></pre>
<h3 id="远程仓库">远程仓库</h3>
<blockquote>
<ol>
<li>通过终端修改</li>
</ol>
</blockquote>
<h4 id="查看远程仓库地址">查看远程仓库地址</h4>
<pre><code>git remote -v
</code></pre>
<h4 id="修改远程仓库地址">修改远程仓库地址</h4>
<pre><code>git remote set-url origin git@github.com/xxx.git
</code></pre>
<blockquote>
<ol start="2">
<li>修改项目下.git/config文件</li>
</ol>
</blockquote>
<pre><code>[remote &quot;origin&quot;]
	# url = git@xxx
	url = git@github.com:xxx.git
</code></pre>
<h3 id="查看分支">查看分支</h3>
<pre><code>git branch 
git branch -a
</code></pre>
<h3 id="切换分支">切换分支</h3>
<pre><code>//本地无分支，加 -b ,相当于 git branch sdpost_dev ，git checkout sdpost_dev
git checkout -b sdpost_dev
//本地已有分支，直接切换
git checkout sdpost_dev
//checkout远端分支
git checkout -b develop origin/develop
</code></pre>
<h3 id="从某个版本代码拉取新的分支">从某个版本代码拉取新的分支</h3>
<pre><code>git checkout -b newbranchname xxxxx(commit id)
</code></pre>
<h3 id="创建一个没有历史记录的新分支">创建一个没有历史记录的新分支</h3>
<pre><code>git checkout --orphan new_dev
git add .
git commit -m &quot;first commit&quot;
// 发布到远端分支
git push origin new_dev:new_dev
</code></pre>
<h3 id="修改分支名称">修改分支名称</h3>
<p>本地分支</p>
<pre><code>git branch -m oldbranchname newbranchname
</code></pre>
<p>远程分支</p>
<pre><code>将本地分支重命名为新分支名称，然后删除远程分支，再把本地分支上传
</code></pre>
<h3 id="把新建的本地分支push到远程服务器远程分支与本地分支同名当然可以随意起名">把新建的本地分支push到远程服务器，远程分支与本地分支同名（当然可以随意起名）</h3>
<pre><code>git push origin wz-jr:wz-jr
</code></pre>
<pre><code>// 创建远端分支的另一种方式
git checkout -b my-test  //在当前分支下创建my-test的本地分支分支
git push origin my-test  //将my-test分支推送到远程
git branch --set-upstream-to=origin/my-test //将本地分支my-test关联到远程分支my-test上   
git branch -a //查看远程分支 
</code></pre>
<h3 id="push所有分支">push所有分支</h3>
<pre><code>git push --all origin
</code></pre>
<h3 id="更新分支信息">更新分支信息</h3>
<blockquote>
<p>远程版本库创建了一个分支后,本地创建远程追踪分支</p>
</blockquote>
<pre><code>git remote update
</code></pre>
<blockquote>
<p>在远程版本库上删除了某一分支,删除本地版本库上那些失效的远程追踪分支</p>
</blockquote>
<p>方法一：</p>
<pre><code>// -p, --prune    prune remotes after fetching
git remote update -p
</code></pre>
<p>方法二：</p>
<pre><code>// 查看哪些分支需要清理
git remote prune origin --dry-run
// 清理
git remote prune
</code></pre>
<blockquote>
<p>本地分支作为下游存在的话，还需要手动清理</p>
</blockquote>
<pre><code>git branch -d xx
</code></pre>
<h3 id="删除分支">删除分支</h3>
<pre><code>git branch -d gte
git branch -D gte(强制删除)
</code></pre>
<h3 id="删除远程分支">删除远程分支</h3>
<pre><code>git push origin --delete 分支名
</code></pre>
<h3 id="恢复删除的分支">恢复删除的分支</h3>
<pre><code>git reflog(找到想要恢复的分支的散列值)
git branch local-test HEAD@{2}
</code></pre>
<h3 id="查看tag">查看tag</h3>
<pre><code>git tag
</code></pre>
<h3 id="查看tag详细信息">查看tag详细信息</h3>
<pre><code>git show v1.0
</code></pre>
<h3 id="添加tag">添加tag</h3>
<pre><code>git tag v1.0
</code></pre>
<h3 id="添加带备注的tag">添加带备注的tag</h3>
<pre><code>git tag -a v1.0 -m &quot;v1.0&quot;
</code></pre>
<h3 id="给指定的某个commit号加tag">给指定的某个commit号加tag</h3>
<pre><code>git tag -a v1.0 9fceb02 -m &quot;v1.0&quot;
</code></pre>
<h3 id="将tag同步到远程服务器">将tag同步到远程服务器</h3>
<pre><code>git push origin v1.0
git push origin --tags //推送所有tag
</code></pre>
<h3 id="切换tag">切换tag</h3>
<pre><code>git checkout v1.0
</code></pre>
<h3 id="获取远程版本">获取远程版本</h3>
<pre><code>git fetch origin tag V1.0
</code></pre>
<h3 id="删除本地tag">删除本地tag</h3>
<pre><code>git tag -d v1.0
</code></pre>
<h3 id="删除远端tag">删除远端tag</h3>
<blockquote>
<p>推送的空的同名版本到线下,达到删除线上版本的目标</p>
</blockquote>
<pre><code>git tag push origin :refs/tags/v1.0
</code></pre>
<h3 id="查看状态">查看状态</h3>
<pre><code>git status
</code></pre>
<h3 id="commit">commit</h3>
<pre><code>//直接填写提交日志
git commit -m 'commit log'
</code></pre>
<h3 id="修改commit">修改commit</h3>
<pre><code>git commit --amend
</code></pre>
<h3 id="pull">pull</h3>
<pre><code>git pull origin master
</code></pre>
<h5 id="pull-错误-you-asked-to-pull-from-the-remote-origin-but-did-not-specify-a-branch-because-this-is-not-the-default-configured-remote-for-your-current-branch-you-must-specify-a-branch-on-the-command-line">pull 错误 “You asked to pull from the remote 'origin', but did not specify a branch. Because this is not the default configured remote for your current branch, you must specify a branch on the command line.”</h5>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/forever_wind/article/details/37506389">Git远程分支和refs文件详解<br>
</a><br>
问题在于没有给当前分支配置merge的路径，git不知道去merge哪个分支。</p>
</blockquote>
<p>我们修改配置文件(.git/config)加入</p>
<pre><code>[branch &quot;wz-jr2&quot;]
	remote = origin
	merge = refs/heads/wz-jr2
</code></pre>
<p>这意味着每次fetch origin的时候更新所有remotes/origin的头指针到refs/heads/下面</p>
<h3 id="push">push</h3>
<pre><code>git push origin master
git push origin HEAD:refs/for/gte
//可提交到指定位置
git push //192.168.0.119/LocalShare/pengbo/adclient develop-post:develop-post
</code></pre>
<h3 id="回退git">回退git</h3>
<pre><code>// !!! Windows下CMD中^是特殊字符，要使用时必须用双引号包括 (git reset &lt;--soft||--mixed||--hard&gt; HEAD&quot;^&quot;)
// !!! 或者 git reset &lt;--soft||--mixed||--hard&gt; HEAD~1
git reset &lt;--soft||--mixed||--hard&gt; HEAD^ (回退到上一个版本) (HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100)
git reset &lt;--soft||--mixed||--hard&gt; xxxxxxxx (回退到指定版本)
</code></pre>
<h3 id="远程版本回退">远程版本回退</h3>
<pre><code>git push origin HEAD --force #远程提交回退
</code></pre>
<h3 id="git回退到某一历史版本后再恢复到之前版本">git回退到某一历史版本后再恢复到之前版本</h3>
<pre><code>git reset --hard xxx
git reflog (git log -g)
git reset --hard xxx
</code></pre>
<h3 id="your-branch-is-behind-originwz-jr-by-1-commit-and-can-be-fast-forwarded">Your branch is behind 'origin/wz-jr' by 1 commit, and can be fast-forwarded.</h3>
<pre><code>is behind表示落后远程版本了，并且可以fast forwarded快速合并
使用git push origin wz-jr --force强制将代码推到服务器，--force使服务器不会拒绝这个更低版本的commit
</code></pre>
<h3 id="撤销修改">撤销修改</h3>
<pre><code>git checkout -- file (命令git checkout -- file意思就是，把文件在工作区的修改全部撤销，这里有两种情况：一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。总之，就是让这个文件回到最近一次git commit或git add时的状态。)
git reset HEAD file (把暂存区的修改撤销掉（unstage），重新放回工作区)
</code></pre>
<h3 id="回退指定文件到指定版本">回退指定文件到指定版本</h3>
<pre><code>git log /e/dev/adclient/app/src/main/AndroidManifest.xml
git reset a28887c24ed89938de7f769eb18b2555de790668 /e/dev/adclient/app/src/main/AndroidManifest.xml
git checkout -- /e/dev/adclient/app/src/main/AndroidManifest.xml
</code></pre>
<h3 id="重新提交-amend">重新提交 amend</h3>
<pre><code>git add .
git commit --amend( --no-edit)
// git push origin gte
// git push origin HEAD:refs/for/gte
// 如果已经push到git仓库,amend后直接push会生成新的记录，需要--force-with-lease
git push --force-with-lease origin master(安全的强制推送)
</code></pre>
<h3 id="暂存恢复-stash">暂存/恢复 stash</h3>
<pre><code>git stash(暂存)
git stash save &quot;&quot; (暂存)
git stash pop(apply last stash and remove it from the list)
git stash list()
git stash pop stash@{1}(取出指定的暂存,取出后会将对应的stash id 从stash list里删除)
git stash apply stash@{1}(取出指定的暂存，取出后会继续保存stash id)
git stash drop stash@{1}(删除指定的暂存)
git stash clear(将栈清空)
</code></pre>
<h3 id="cherry-pick">cherry-pick</h3>
<pre><code>// 将另一个分支上的一个提交合并到本分支
git cherry-pick xxxx(commit id)

// 合并多条
// ==注意，不包含xxx1==
git cherry-pick xxx1..xxx10
// ==包含xxx1==
git cherry-pick xxx1^..xxx10

// 继续合并 || 取消合并
git cherry-pick --continue || --abort
</code></pre>
<h3 id="revert">revert</h3>
<pre><code>git revert xxx
git commit
// git push origin gte
git push origin HEAD:refs/for/sdpost_dev
</code></pre>
<h3 id="fetchrebase">fetch/rebase</h3>
<pre><code>首先用git fetch返回服务器上的代码
用git rebase合并
    &gt; 合并冲突
    &gt; git add .
    &gt; 用git rebase --continue继续没完成的合并
    &gt; 重新提交git commit --amend
最后就可以用git push更新到服务器上去。
</code></pre>
<pre><code>git pull --rebase origin develop-post(git pull --rebase = git fetch + git rebase)
</code></pre>
<h3 id="取消本次rebase">取消本次rebase</h3>
<pre><code>git rebase --abort
</code></pre>
<h3 id="git-bisect-查找哪一次代码提交引入了错误">git bisect 查找哪一次代码提交引入了错误</h3>
<blockquote>
<p>参考：<a href="http://www.ruanyifeng.com/blog/2018/12/git-bisect.html">git bisect 命令教程</a></p>
</blockquote>
<blockquote>
<p>它的原理很简单，就是将代码提交的历史，按照两分法不断缩小定位。所谓&quot;两分法&quot;，就是将代码历史一分为二，确定问题出在前半部分，还是后半部分，不断执行这个过程，直到范围缩小到某一次代码提交。</p>
</blockquote>
<pre><code>// &quot;终点&quot;是最近的提交，&quot;起点&quot;是更久以前的提交
git bisect start [终点] [起点]

eg:
git bisect start 100 1

执行上面的命令以后，代码库就会切换到这段范围正当中的那一次提交，即50

如果没有问题，那么1-50之间是正常的，执行
git bisect good

那么Git就自动切换到后半段的中点，即50-100，即75

如果出现问题，那么50-75之间有问题，执行
git bisect bad

Git就自动切换到第50次到第75次的中点（第63次提交）

重复执行上述操作，直到成功找到出问题的那一次提交为止，Git 会给出如下的提示

xxx is the first bad commit

查出问题后，执行
git bisect reset

退出查错

现在就可以开始修复错误了。
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello EveryOne]]></title>
        <id>https://wmszhe.github.io/post/hello_everyone/</id>
        <link href="https://wmszhe.github.io/post/hello_everyone/">
        </link>
        <updated>2019-06-15T11:18:56.000Z</updated>
        <summary type="html"><![CDATA[<p>👏 欢迎来到 <strong>wzhuiJ!</strong> 👏</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏 欢迎来到 <strong>wzhuiJ!</strong> 👏</p>
<!-- more --> 
<blockquote>
<p>Time: 2019年6月15日，周六。</p>
</blockquote>
<ol>
<li>本网站通过Github Pages创建。创建过程参考<a href="https://sspai.com/post/54608">GitHub Pages 搭建教程</a></li>
<li>使用<a href="https://gridea.dev/">Gridea</a>管理本网站</li>
<li>本站使用<a href="https://github.com/Alanrk/Gridea-theme-clean">Clean主题</a>，经过<a href="https://github.com/wmszhe/Gridea-theme-clean">适量修改</a>。</li>
<li>本网站主要记录
<ul>
<li>工作笔记</li>
<li>日常</li>
<li>备忘</li>
</ul>
</li>
<li>随缘更新</li>
</ol>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>