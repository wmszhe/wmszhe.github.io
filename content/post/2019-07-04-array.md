---
title:       '数组Array'
date:        '2019-07-04'
description: ''
author:      'wmszhe'
image:       ''
tags:
    - 数据结构
categories:
    - 
---

<!--more-->

### 数组 Array

> 数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。

- 1. 线性表
  
- 2. 连续的内存空间和相同的数据结构

    > 如果我们申请一个 100MB 大小的数组，当内存中没有连续的、足够大的存储空间时，即便内存的剩余总可用空间大于 100MB，仍然会申请失败。

#### 根据下标随机访问数组元素的方式

一个长度为 10 的 int 类型的数组 int[] a = new int[10] , 计算机给数组 a[10]，分配了一块连续内存空间 1000～1039，其中，内存块的首地址为 base_address = 1000。

![](https://raw.githubusercontent.com/wmszhe/pichub/master/imgs/98df8e702b14096e7ee4a5141260cdc4.jpg)

通过下面的寻址公式，计算出该元素存储的内存地址：

> 一维数组内存寻址：

```
a[i]_address = base_address + i * data_type_size
```

> 二维数组内存寻址：

对于 m * n 的数组，a [i][ j ] (i < m,j < n)的地址为：
```
address = base_address + ( i * n + j) * type_size
```

==**数组是适合查找操作，但是查找的时间复杂度并不为 O(1)。即便是排好序的数组，用二分查找，时间复杂度也是 O(logn)。所以，正确的表述应该是，数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。**==


#### 插入删除低效原因

假设数组的长度为 n，现在，如果我们需要将一个数据插入到数组中的第 k 个位置。为了把第 k 个位置腾出来，给新来的数据，我们需要将第 k～n 这部分的元素都顺序地往后挪一位。

如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为 O(1)。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是 O(n)。 因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为 (1+2+…n)/n=O(n)。

> 如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数组插入到第 k 个位置，为了避免大规模的数据搬移，我们还有一个简单的办法就是，直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置。

eg: 

假设数组 a[10] 中存储了如下 5 个元素：a，b，c，d，e。

我们现在需要将元素 x 插入到第 3 个位置。我们只需要将 c 放入到 a[5]，将 a[2] 赋值为 x 即可。最后，数组中的元素如下： a，b，x，d，e，c。

![](https://raw.githubusercontent.com/wmszhe/pichub/master/imgs/3f70b4ad9069ec568a2caaddc231b7dc.jpg)


> 删除时，在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。我们可以多次删除操作集中在一起执行

eg:

数组 a[10] 中存储了 8 个元素：a，b，c，d，e，f，g，h。现在，我们要依次删除 a，b，c 三个元素

为了避免 d，e，f，g，h 这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。

![](https://raw.githubusercontent.com/wmszhe/pichub/master/imgs/b69b8c5dbf6248649ddab7d3e7cfd7e5.jpg)


#### 容器 ArrayList

> 针对数组类型，很多语言都提供了容器类，比如 Java 中的 ArrayList

- 优势：
    - 1. 可以将很多数组操作的细节封装起来，比如前面提到的数组插入、删除数据时需要搬移其他数据等
    - 2. 支持动态扩容 ==**不过，需要注意，因为扩容操作涉及内存申请和数据搬移，是比较耗时的。所以，如果事先能确定需要存储的数据大小，最好在创建 ArrayList 的时候事先指定数据大小**==
- 不足：
    - 1. Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。
    - 2. 如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组
    - 要表示多维数组时，用数组往往会更加直观

